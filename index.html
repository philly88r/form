<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chainlink Fence Calculator</title>
    <style>
        /* ... (keep all existing styles from the previous version) ... */

        /* Add styles for arrow buttons */
        .action-button.move {
            color: #6b7280; /* Neutral color */
            font-size: 1.2em; /* Make arrows slightly larger */
            line-height: 1;
            padding: 1px 4px; /* Adjust padding */
            vertical-align: middle;
        }
        .action-button.move:hover:not(:disabled) {
            background-color: #e5e7eb;
            color: #374151;
        }
        .action-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .action-buttons-container {
            /* Ensure enough space for all buttons */
            white-space: nowrap;
             margin-left: auto; /* Push buttons to the right in flex container */
             padding-left: 10px; /* Space between label/input and buttons */
        }

        /* Style for calculated fields */
        .input-field.calculated-field {
            background-color: #e5e7eb; /* Light gray background */
            color: #4b5563; /* Darker text */
            cursor: not-allowed;
            font-weight: bold;
        }

         /* Ensure editable labels handle buttons correctly */
         .editable-label {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            flex-wrap: nowrap; /* Prevent wrapping by default */
        }
         .editable-label > span:first-child,
         .editable-label > label:first-child,
         .editable-label > input:first-child {
             flex-grow: 1; /* Label/Input takes space */
             margin-right: 5px; /* Minimal space before buttons */
             min-width: 100px; /* Prevent label collapsing too much */
         }
         .post-group-title {
              display: flex; /* Make title container flex */
              align-items: center;
              justify-content: space-between; /* Push buttons to the end */
         }
          .post-group-title .action-buttons-container {
              margin-left: 10px; /* Space before buttons */
              flex-shrink: 0; /* Prevent buttons shrinking */
          }
           .post-field-item .editable-label .action-buttons-container {
               margin-left: 5px; /* Smaller margin for sub-field buttons */
           }

    </style>
</head>
<body>
    <!-- ... (keep existing HTML structure: form-container, admin panel, form) ... -->
     <div class="form-container" id="fenceCalculator">
        <h2 class="form-title">Chainlink Fence Calculator</h2>

        <button id="toggleEditorMode" class="admin-button" style="margin-bottom: 20px;">
            Enter Editor Mode
        </button>

        <div id="adminPanel" class="admin-controls-container" style="display: none;">
             <h3 class="admin-controls-title">Form Editor</h3>
             <button id="toggleAddQuestionForm" class="admin-button primary">
                 Add New Question
             </button>
             
             <!-- Add Download Button -->
             <button id="downloadFormButton" class="admin-button" style="background-color: #3b82f6; margin-left: 10px;">
                 Download Form HTML/CSS
             </button>

             <div id="addQuestionForm" class="add-question-form" style="display: none;">
                 <h4>Add New Question</h4>
                 <div id="editingPostGroupInfo" style="display: none; margin-bottom: 10px; padding: 5px; background-color: #f0f9ff; border-left: 3px solid #3b82f6; color: #1e40af;"></div>
                 <div class="question-form-field">
                     <label class="label">Question ID (unique identifier)<span class="required-indicator">*</span></label>
                     <input id="newQuestionId" type="text" class="input-field" placeholder="E.g., fenceHeight">
                 </div>

                 <div class="question-form-field">
                     <label class="label">Question Text<span class="required-indicator">*</span></label>
                     <input id="newQuestionText" type="text" class="input-field" placeholder="E.g., What is the fence height?">
                 </div>

                 <div class="question-form-field">
                     <label class="label">Input Type</label>
                     <select id="newQuestionInputType" class="select-dropdown">
                         <option value="text">Text</option>
                         <option value="number">Number</option>
                         <option value="select">Select (Dropdown)</option>
                     </select>
                 </div>

                 <div id="optionsField" class="question-form-field" style="display: none;">
                     <label class="label">Options (comma-separated)<span class="required-indicator">*</span></label>
                     <input id="newQuestionOptions" type="text" class="input-field" placeholder="E.g., Option 1, Option 2, Option 3">
                 </div>

                 <div class="question-form-field">
                     <label class="label">Section</label>
                     <select id="newQuestionSection" class="select-dropdown">
                         <!-- Dynamically populate sections later? Or keep static list -->
                         <option value="Basic Info">Basic Info</option>
                         <option value="Posts">Posts</option>
                         <option value="Gates">Gates</option>
                         <option value="Line Posts">Line Posts</option>
                         <option value="Extra Options">Extra Options</option>
                         <option value="Other">Other</option>
                     </select>
                 </div>

                 <div class="question-form-field">
                     <label class="label">Default Value (optional)</label>
                     <input id="newQuestionDefault" type="text" class="input-field" placeholder="Default value (if any)">
                 </div>

                 <div class="question-form-field">
                     <label class="label">Required Field</label>
                     <input id="newQuestionRequired" type="checkbox" style="margin-right: 8px; transform: scale(1.1);">
                 </div>

                 <div class="question-form-field">
                    <label class="label">
                        <input id="newQuestionCalculated" type="checkbox" style="margin-right: 8px; transform: scale(1.1);">
                        Calculated Field (Read-Only)
                    </label>
                </div>

                 <div class="question-form-field">
                    <label class="label">Dependency: Only show if Question ID</label>
                    <input id="newQuestionDependentOn" type="text" class="input-field" placeholder="e.g., includeBarbedWire">
                </div>
                <div class="question-form-field">
                    <label class="label">Has the value</label>
                    <input id="newQuestionDependentValue" type="text" class="input-field" placeholder="e.g., Yes">
                </div>

                 <div class="question-form-field">
                     <label class="label">Display Order</label>
                     <input id="newQuestionOrder" type="number" value="999" class="input-field">
                 </div>

                 <button id="addQuestionButton" class="admin-button success">
                     Add Question
                 </button>
                  <button id="cancelAddQuestionButton" type="button" class="admin-button" style="background-color: #6b7280;">
                     Cancel
                 </button>
             </div>
         </div>

        <form id="fenceCalculatorForm">
            <div id="formSections"></div>
            <button type="submit" class="submit-button">Calculate Material List / Cost</button>
        </form>
    </div>

    <script>
        // --- Configuration ---
        const initialChainlinkFenceQuestions = [
            // --- Basic Info Section ---
            {
                id: 'numberOfPulls',
                question_text: 'Number of Fence Pulls/Sections',
                input_type: 'number',
                default: '2',
                required: true,
                section: 'Basic Info',
                order: 10,
                dynamic_fields: {
                    container_id_prefix: 'dynamic-pulls-',
                    container_class: 'dynamic-fields-container',
                    title: 'Fence Pull/Section Lengths',
                    grid_class: 'dynamic-fields-grid',
                    item_class: 'dynamic-field-item',
                    template: {
                        id_template: 'pull{n}Length',
                        text_template: 'Length of Pull/Section {n} (ft)',
                        input_type: 'number',
                        placeholder: 'Enter length',
                        required: true,
                        style: { labelColor: '#1e40af', borderColor: '#3b82f6' }
                    }
                }
            },
            {
                id: 'totalFootage',
                question_text: 'Total Linear Length (ft)',
                input_type: 'number',
                required: true,
                calculated: true, // Mark as calculated
                section: 'Basic Info',
                order: 20
            },
            {
                id: 'fenceHeight',
                question_text: 'Height of Fence',
                input_type: 'number',
                default: '4',
                required: true,
                section: 'Basic Info',
                order: 30
            },
            {
                id: 'commercialOrResidential',
                question_text: 'Project Type',
                input_type: 'select',
                options: ['Commercial', 'Residential'],
                default: 'Commercial',
                required: true,
                section: 'Basic Info',
                order: 40
            },
            {
                id: 'fenceMaterial',
                question_text: 'Fence Material Color',
                input_type: 'select',
                options: ['Galv', 'Black'],
                default: 'Galv',
                required: true,
                section: 'Basic Info',
                order: 50
            },
            {
                id: 'meshGauge',
                question_text: 'Mesh Gauge/Type (Select based on Material)',
                input_type: 'select',
                options: ['Residential 11.5 gauge', 'Commercial 9 gauge', 'Residential 9 gauge', 'Commercial 8 gauge'],
                default: 'Residential 11.5 gauge',
                required: true,
                section: 'Basic Info',
                order: 60
            },
            {
                id: 'meshFoldType',
                question_text: 'Mesh Fold Type',
                input_type: 'select',
                options: ['KK', 'KT'],
                default: 'KK',
                required: true,
                section: 'Basic Info',
                order: 70
            },
            // --- Gates Section ---
            {
                id: 'numberOfSingleGates',
                question_text: 'Number of Single Gates',
                input_type: 'number',
                default: '0',
                required: true,
                section: 'Gates',
                order: 200,
                dynamic_fields: {
                    type: 'gate', gate_type: 'single', container_id_prefix: 'gate-fields-single-',
                    container_class: 'gate-fields-container', title_template: 'Single Gate {n} Specifications',
                    grid_class: 'gate-fields-grid', item_class: 'gate-field-item',
                    post_container_class: 'gate-posts-container', post_title_template: 'Gate {n} Post Details', post_grid_class: 'gate-fields-grid',
                    template: {
                        fields: [
                            { id_template: 'singleGate{n}Width', text_template: 'Width (ft)', input_type: 'number', required: true, order: 1 },
                            { id_template: 'singleGate{n}Height', text_template: 'Height (ft)', input_type: 'number', required: true, order: 2 },
                            { id_template: 'singleGate{n}FrameType', text_template: 'Frame Type', input_type: 'select', options: ['1 5/8', '2'], required: true, order: 3 },
                            { id_template: 'singleGate{n}LatchType', text_template: 'Latch Type', input_type: 'select', options: ['Fork', 'Fork Single', 'Industrial Swing'], required: true, order: 4 }
                        ],
                        post_fields: [
                            { id_template: 'singleGate{n}PostDiameter', text_template: 'Post Diameter', input_type: 'select', options: ['2 3/8', '2 7/8', '4', '6 5/8'], required: true, order: 101 },
                            { id_template: 'singleGate{n}PostThickness', text_template: 'Post Thickness', input_type: 'select', options: ['SCH 40', 'Commercial SCH 40', 'Industrial SCH 40'], required: true, order: 102 },
                            { id_template: 'singleGate{n}PostHoleDepth', text_template: 'Post Hole Depth (in)', input_type: 'number', required: true, order: 103 },
                            { id_template: 'singleGate{n}PostHoleWidth', text_template: 'Post Hole Width (in)', input_type: 'number', required: true, order: 104 }
                        ],
                        style: { labelColor: '#047857', borderColor: '#10b981', postLabelColor: '#3f6212', postBorderColor: '#84cc16' }
                    }
                }
            },
            {
                id: 'numberOfDoubleGates',
                question_text: 'Number of Double Gates',
                input_type: 'number',
                default: '0',
                required: true,
                section: 'Gates',
                order: 210,
                dynamic_fields: {
                    type: 'gate', gate_type: 'double', container_id_prefix: 'gate-fields-double-',
                    container_class: 'gate-fields-container', title_template: 'Double Gate {n} Specifications',
                    grid_class: 'gate-fields-grid', item_class: 'gate-field-item',
                    post_container_class: 'gate-posts-container', post_title_template: 'Gate {n} Post Details', post_grid_class: 'gate-fields-grid',
                    template: {
                        fields: [
                            { id_template: 'doubleGate{n}Width', text_template: 'Width (ft)', input_type: 'number', required: true, order: 1 },
                            { id_template: 'doubleGate{n}Height', text_template: 'Height (ft)', input_type: 'number', required: true, order: 2 },
                            { id_template: 'doubleGate{n}FrameType', text_template: 'Frame Type', input_type: 'select', options: ['1 5/8', '2'], required: true, order: 3 },
                            { id_template: 'doubleGate{n}LatchType', text_template: 'Latch Type', input_type: 'select', options: ['Drop Rod', 'Cane Bolt'], required: true, order: 4 }
                        ],
                        post_fields: [
                            { id_template: 'doubleGate{n}PostDiameter', text_template: 'Post Diameter', input_type: 'select', options: ['2 3/8', '2 7/8', '4', '6 5/8'], required: true, order: 101 },
                            { id_template: 'doubleGate{n}PostThickness', text_template: 'Post Thickness', input_type: 'select', options: ['SCH 40', 'Commercial SCH 40', 'Industrial SCH 40'], required: true, order: 102 },
                            { id_template: 'doubleGate{n}PostHoleDepth', text_template: 'Post Hole Depth (in)', input_type: 'number', required: true, order: 103 },
                            { id_template: 'doubleGate{n}PostHoleWidth', text_template: 'Post Hole Width (in)', input_type: 'number', required: true, order: 104 }
                        ],
                        style: { labelColor: '#7e22ce', borderColor: '#a855f7', postLabelColor: '#3f6212', postBorderColor: '#84cc16' }
                    }
                }
            },
            {
                id: 'numberOfSlidingGates',
                question_text: 'Number of Sliding Gates',
                input_type: 'number',
                default: '0',
                required: true,
                section: 'Gates',
                order: 220,
                dynamic_fields: {
                    type: 'gate', gate_type: 'sliding', container_id_prefix: 'gate-fields-sliding-',
                    container_class: 'gate-fields-container', title_template: 'Sliding Gate {n} Specifications',
                    grid_class: 'gate-fields-grid', item_class: 'gate-field-item',
                    post_container_class: 'gate-posts-container', post_title_template: 'Gate {n} Post Details', post_grid_class: 'gate-fields-grid',
                    template: {
                        fields: [
                            { id_template: 'slidingGate{n}Width', text_template: 'Width (ft)', input_type: 'number', required: true, order: 1 },
                            { id_template: 'slidingGate{n}Height', text_template: 'Height (ft)', input_type: 'number', required: true, order: 2 },
                            { id_template: 'slidingGate{n}FrameType', text_template: 'Frame Type', input_type: 'select', options: ['1 5/8', '2'], required: true, order: 3 },
                            { id_template: 'slidingGate{n}TrackType', text_template: 'Operator', input_type: 'select', options: ['Manual', 'Automatic'], required: true, order: 4 }
                        ],
                        post_fields: [
                            { id_template: 'slidingGate{n}PostDiameter', text_template: 'Post Diameter', input_type: 'select', options: ['2 3/8', '2 7/8', '4', '6 5/8'], required: true, order: 101 },
                            { id_template: 'slidingGate{n}PostThickness', text_template: 'Post Thickness', input_type: 'select', options: ['SCH 40', 'Commercial SCH 40', 'Industrial SCH 40'], required: true, order: 102 },
                            { id_template: 'slidingGate{n}PostHoleDepth', text_template: 'Post Hole Depth (in)', input_type: 'number', required: true, order: 103 },
                            { id_template: 'slidingGate{n}PostHoleWidth', text_template: 'Post Hole Width (in)', input_type: 'number', required: true, order: 104 }
                        ],
                        style: { labelColor: '#b45309', borderColor: '#f59e0b', postLabelColor: '#3f6212', postBorderColor: '#84cc16' }
                    }
                }
            },
            // --- Posts Section ---
            {
                id: 'useFlangedPosts',
                question_text: 'Use Flanged Posts?',
                input_type: 'select',
                options: ['Yes', 'No'],
                default: 'No',
                required: true,
                section: 'Posts',
                order: 100
            },
            { // Terminal Posts Group
                id: 'terminalPostGroup',
                question_text: 'Terminal Posts',
                is_post_group: true,
                section: 'Posts',
                order: 110,
                post_group_questions: [
                    { id: 'numTerminalPosts', question_text: 'Number of Terminal Posts', input_type: 'number', required: true, order: 1 },
                    { id: 'terminalPostDiameter', question_text: 'Terminal Post Diameter', input_type: 'select', options: ['2 3/8', '2 7/8', '4', '6 5/8'], required: true, order: 2 },
                    { id: 'terminalPostThickness', question_text: 'Terminal Post Thickness', input_type: 'select', options: ['SCH 40', 'Commercial SCH 40', 'Industrial SCH 40'], required: true, order: 3 },
                    { id: 'terminalPostHoleDepth', question_text: 'Hole Depth (inches)', input_type: 'number', required: true, order: 4 },
                    { id: 'terminalPostHoleWidth', question_text: 'Hole Width (inches)', input_type: 'number', required: true, order: 5 }
                ]
            },
            { // Corner Posts Group
                id: 'cornerPostGroup',
                question_text: 'Corner Posts',
                is_post_group: true,
                section: 'Posts',
                order: 120,
                post_group_questions: [
                    { id: 'numCornerPosts', question_text: 'Number of Corner Posts', input_type: 'number', required: true, order: 1 },
                    { id: 'cornerPostDiameter', question_text: 'Corner Post Diameter', input_type: 'select', options: ['2 3/8', '2 7/8', '4', '6 5/8'], required: true, order: 2 },
                    { id: 'cornerPostThickness', question_text: 'Corner Post Thickness', input_type: 'select', options: ['SCH 40', 'Commercial SCH 40', 'Industrial SCH 40'], required: true, order: 3 },
                    { id: 'cornerPostHoleDepth', question_text: 'Hole Depth (inches)', input_type: 'number', required: true, order: 4 },
                    { id: 'cornerPostHoleWidth', question_text: 'Hole Width (inches)', input_type: 'number', required: true, order: 5 }
                ]
            },
            { // Flanged Posts Centered Group
                id: 'flangedPostCenteredGroup',
                question_text: 'Flanged Posts Centered',
                is_post_group: true,
                section: 'Posts',
                order: 130,
                dependent_on: 'useFlangedPosts', // Dependency
                dependent_value: 'Yes',         // Dependency
                post_group_questions: [
                    { id: 'numFlangedPostsCentered', question_text: 'Number of Flanged Posts Centered', input_type: 'number', required: true, order: 1 },
                    { id: 'flangedPostCenteredDiameter', question_text: 'Flanged Post Centered Diameter', input_type: 'select', options: ['2 3/8', '2 7/8', '4', '6 5/8'], required: true, order: 2 },
                    { id: 'flangedPostCenteredThickness', question_text: 'Flanged Post Centered Thickness', input_type: 'select', options: ['SCH 40', 'Commercial SCH 40', 'Industrial SCH 40'], required: true, order: 3 },
                    { id: 'flangedPostCenteredHoleDepth', question_text: 'Hole Depth (inches)', input_type: 'number', required: true, order: 4 },
                    { id: 'flangedPostCenteredHoleWidth', question_text: 'Hole Width (inches)', input_type: 'number', required: true, order: 5 }
                ]
            },
            { // Flanged Posts Off Centered Group
                id: 'flangedPostOffCenteredGroup',
                question_text: 'Flanged Posts Off Centered',
                is_post_group: true,
                section: 'Posts',
                order: 140,
                dependent_on: 'useFlangedPosts', // Dependency
                dependent_value: 'Yes',         // Dependency
                post_group_questions: [
                    { id: 'numFlangedPostsOffCentered', question_text: 'Number of Flanged Posts Off Centered', input_type: 'number', required: true, order: 1 },
                    { id: 'flangedPostOffCenteredDiameter', question_text: 'Flanged Post Off Centered Diameter', input_type: 'select', options: ['2 3/8', '2 7/8', '4', '6 5/8'], required: true, order: 2 },
                    { id: 'flangedPostOffCenteredThickness', question_text: 'Flanged Post Off Centered Thickness', input_type: 'select', options: ['SCH 40', 'Commercial SCH 40', 'Industrial SCH 40'], required: true, order: 3 },
                    { id: 'flangedPostOffCenteredHoleDepth', question_text: 'Hole Depth (inches)', input_type: 'number', required: true, order: 4 },
                    { id: 'flangedPostOffCenteredHoleWidth', question_text: 'Hole Width (inches)', input_type: 'number', required: true, order: 5 }
                ]
            },
            // --- Line Posts Section ---
            {
                id: 'linePostSpacing',
                question_text: 'Line Post Spacing (ft)',
                input_type: 'number',
                default: '10',
                required: true,
                section: 'Line Posts',
                order: 300
            },
            { // Line Posts Group
                id: 'linePostGroup',
                question_text: 'Line Posts',
                is_post_group: true,
                section: 'Line Posts',
                order: 310,
                post_group_questions: [
                    { id: 'numLinePosts', question_text: 'Number of Line Posts', input_type: 'number', required: true, calculated: true, order: 1 },
                    { id: 'linePostDiameter', question_text: 'Line Post Diameter', input_type: 'select', options: ['1 5/8', '1 7/8', '2 3/8', '2 7/8'], required: true, order: 2 },
                    { id: 'linePostThickness', question_text: 'Line Post Thickness', input_type: 'select', options: ['SCH 20', 'SCH 40', 'Commercial SCH 40'], required: true, order: 3 },
                    { id: 'linePostHoleDepth', question_text: 'Hole Depth (inches)', input_type: 'number', required: true, order: 4 },
                    { id: 'linePostHoleWidth', question_text: 'Hole Width (inches)', input_type: 'number', required: true, order: 5 }
                ]
            },
            // --- Extra Options Section ---
            {
                id: 'includeTopRail',
                question_text: 'Include Top Rail?',
                input_type: 'select',
                options: ['Yes', 'No'],
                default: 'Yes',
                required: true,
                section: 'Extra Options',
                order: 400
            },
            {
                id: 'includeMidRail',
                question_text: 'Include Mid Rail?',
                input_type: 'select',
                options: ['Yes', 'No'],
                default: 'No',
                required: true,
                section: 'Extra Options',
                order: 410
            },
            {
                id: 'includeBottomRail',
                question_text: 'Include Bottom Rail?',
                input_type: 'select',
                options: ['Yes', 'No'],
                default: 'No',
                required: true,
                section: 'Extra Options',
                order: 420
            },
            {
                id: 'includeBarbedWire',
                question_text: 'Include Barbed Wire?',
                input_type: 'select',
                options: ['Yes', 'No'],
                default: 'No',
                required: true,
                section: 'Extra Options',
                order: 430
            },
            {
                id: 'numBarbedWireStrands',
                question_text: 'Number of Barbed Wire Strands',
                input_type: 'select',
                options: ['1', '2', '3'],
                default: '3',
                required: true,
                section: 'Extra Options',
                order: 440,
                dependent_on: 'includeBarbedWire',
                dependent_value: 'Yes'
            },
            {
                id: 'includeTensionWire',
                question_text: 'Include Tension Wire?',
                input_type: 'select',
                options: ['Yes', 'No'],
                default: 'Yes',
                required: true,
                section: 'Extra Options',
                order: 450
            },
            {
                id: 'includePrivacySlats',
                question_text: 'Include Privacy Slats?',
                input_type: 'select',
                options: ['Yes', 'No'],
                default: 'No',
                required: true,
                section: 'Extra Options',
                order: 460
            },
            {
                id: 'privacySlatsType',
                question_text: 'Privacy Slat Type',
                input_type: 'select',
                options: ['Standard', 'Heavy Duty', 'Extra Heavy Duty'],
                default: 'Standard',
                required: true,
                section: 'Extra Options',
                order: 470,
                dependent_on: 'includePrivacySlats',
                dependent_value: 'Yes'
            },
            {
                id: 'privacySlatsColor',
                question_text: 'Privacy Slat Color',
                input_type: 'select',
                options: ['Black', 'Brown', 'Green', 'White', 'Beige'],
                default: 'Black',
                required: true,
                section: 'Extra Options',
                order: 480,
                dependent_on: 'includePrivacySlats',
                dependent_value: 'Yes'
            }
        ];

        // --- State Variables ---
        let questions = JSON.parse(JSON.stringify(initialChainlinkFenceQuestions));
        let isAdminMode = false;
        let editingQuestionId = null;
        let showAddQuestionForm = false;
        let answers = {};
        let dynamicFieldStructures = { pulls: [], singleGates: [], doubleGates: [], slidingGates: [] };

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('toggleEditorMode').addEventListener('click', toggleEditorMode);
            document.getElementById('toggleAddQuestionForm').addEventListener('click', toggleAddQuestionFormUI);
            document.getElementById('addQuestionButton').addEventListener('click', handleAddQuestion);
            document.getElementById('cancelAddQuestionButton').addEventListener('click', () => toggleAddQuestionFormUI(false));
            document.getElementById('newQuestionInputType').addEventListener('change', toggleOptionsField);
            document.getElementById('newQuestionCalculated').addEventListener('change', toggleCalculatedFieldOptions);
            document.getElementById('fenceCalculatorForm').addEventListener('submit', handleFormSubmit);
            document.getElementById('downloadFormButton').addEventListener('click', downloadFormHtmlCss);

            initializeFormState();
            renderForm();
            recalculateAndUpdateFields();
        });

        // --- Core Functions ---
        function createInputElement(question) {
            const input = document.createElement('input');
            input.className = 'input-field';
            input.type = question.input_type || 'text';
            input.id = question.id;
            input.value = answers[question.id] || '';
            input.required = !!question.required;
            input.disabled = !!question.calculated;
            input.addEventListener('input', e => handleChange(question.id, e.target.value));
            return input;
        }

        function createLabelElement(question) {
            const label = document.createElement('label');
            label.className = 'label';
            label.htmlFor = question.id;
            label.textContent = question.question_text;
            if (question.required) {
                const req = document.createElement('span');
                req.className = 'required-indicator';
                req.textContent = '*';
                label.appendChild(req);
            }
            return label;
        }

        function renderDynamicSection(formSections) {
            // Example: render dynamic fields for pulls, gates, etc.
            // (You can expand this as needed for your use case)
        }

        function initializeFormState() {
            console.log('Initializing form state...');
            answers = {};
            dynamicFieldStructures = { pulls: [], singleGates: [], doubleGates: [], slidingGates: [] };

            let maxOrder = 0;
            const assignOrder = (item) => {
                if (item.order === undefined || item.order === null) {
                    item.order = 9999;
                }
                if (!isNaN(item.order) && item.order > maxOrder) maxOrder = item.order;
            };

            questions.forEach(q => {
                assignOrder(q);
                if (q.is_post_group && q.post_group_questions) {
                    q.post_group_questions.forEach(assignOrder);
                }
            });

            questions.forEach(q => {
                if (q.default !== undefined) {
                    answers[q.id] = q.default;
                }
                if (q.dynamic_fields) {
                    const count = parseInt(answers[q.id] || '0', 10);
                    if (!isNaN(count) && count >= 0) { // Allow 0 count
                        updateDynamicFields(q.id, count);
                    }
                }
                // Init answers for post group sub-questions
                if (q.is_post_group && q.post_group_questions) {
                    q.post_group_questions.forEach(subQ => {
                        if (subQ.default !== undefined) {
                            answers[subQ.id] = subQ.default;
                        }
                    });
                }
            });

            // Recalculate after defaults are set
            recalculateAndUpdateFields();
            console.log('Initial answers:', answers);
        }

        function handleChange(id, value) {
            answers[id] = value;
            
            // Check if this is a trigger for dynamic fields
            const triggerQuestion = questions.find(q => q.id === id && q.dynamic_fields);
            if (triggerQuestion) {
                const count = parseInt(value, 10);
                if (!isNaN(count) && count >= 0) { // Allow 0 count
                    updateDynamicFields(id, count);
                    renderForm(); // Re-render to show/hide dynamic fields
                }
            }
            
            // Handle dependencies (show/hide questions based on this value)
            if (questions.some(q => q.dependent_on === id)) {
                renderForm(); // Re-render to show/hide dependent questions
            }
            
            // Update calculated fields
            recalculateAndUpdateFields();
        }

        function recalculateAndUpdateFields() {
            // Example: Calculate total footage from pull lengths
            const pullLengths = Object.keys(answers)
                .filter(key => key.startsWith('pull') && key.endsWith('Length'))
                .map(key => parseFloat(answers[key]))
                .filter(val => !isNaN(val));
            
            if (pullLengths.length > 0) {
                const totalFootage = pullLengths.reduce((sum, len) => sum + len, 0);
                answers['totalFootage'] = totalFootage.toString();
                updateCalculatedFieldDisplay('totalFootage');
            }
            
            // Example: Calculate number of line posts based on total footage and spacing
            const totalFootage = parseFloat(answers['totalFootage']);
            const linePostSpacing = parseFloat(answers['linePostSpacing']);
            if (!isNaN(totalFootage) && !isNaN(linePostSpacing) && linePostSpacing > 0) {
                const numLinePosts = Math.ceil(totalFootage / linePostSpacing) - 1; // -1 because terminal posts are separate
                answers['numLinePosts'] = Math.max(0, numLinePosts).toString();
                updateCalculatedFieldDisplay('numLinePosts');
            }
            
            // Add more calculations as needed
        }

        function updateCalculatedFieldDisplay(specificId = null) {
            const calculatedQuestions = getAllQuestionsIncludingDynamic().filter(q => q.calculated);
            
            calculatedQuestions.forEach(question => {
                if (specificId && question.id !== specificId) return;
                
                const input = document.getElementById(question.id);
                if (input) {
                    input.value = answers[question.id] || '';
                }
            });
        }

        function handleFormSubmit(event) {
            event.preventDefault();
            
            // Validate form
            const requiredQuestions = getAllQuestionsIncludingDynamic().filter(q => q.required && !q.calculated);
            const missingAnswers = requiredQuestions.filter(q => !answers[q.id]);
            
            if (missingAnswers.length > 0) {
                alert(`Please fill in all required fields: ${missingAnswers.map(q => q.question_text).join(', ')}`);
                return;
            }
            
            // Process form submission
            console.log('Form submitted with answers:', answers);
            alert('Form submitted successfully! (This is a placeholder - implement your actual submission logic)');
        }

        function toggleEditorMode() {
            console.log('Toggling editor mode, current state:', isAdminMode);
            isAdminMode = !isAdminMode;
            document.getElementById('adminPanel').style.display = isAdminMode ? 'block' : 'none';
            document.getElementById('toggleEditorMode').textContent = isAdminMode ? 'Exit Editor Mode' : 'Enter Editor Mode';
            if (!isAdminMode) {
                toggleAddQuestionFormUI(false);
                editingQuestionId = null;
                document.getElementById('editingPostGroupInfo').style.display = 'none';
            }
            renderForm();
            console.log('Editor mode toggled to:', isAdminMode);
        }

        function toggleAddQuestionFormUI(forceState = null) {
            showAddQuestionForm = forceState !== null ? forceState : !showAddQuestionForm;
            const addQuestionForm = document.getElementById('addQuestionForm');
            const toggleButton = document.getElementById('toggleAddQuestionForm');

            addQuestionForm.style.display = showAddQuestionForm ? 'block' : 'none';
            toggleButton.textContent = showAddQuestionForm ? 'Cancel Adding Question' : 'Add New Question';
            toggleButton.className = showAddQuestionForm ? 'admin-button danger' : 'admin-button primary';

            if (showAddQuestionForm) {
                addQuestionForm.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            } else {
                // Reset form fields
                document.getElementById('newQuestionId').value = '';
                document.getElementById('newQuestionText').value = '';
                document.getElementById('newQuestionInputType').value = 'text';
                document.getElementById('newQuestionSection').value = 'Basic Info';
                document.getElementById('newQuestionDefault').value = '';
                document.getElementById('newQuestionRequired').checked = false;
                document.getElementById('newQuestionCalculated').checked = false;
                document.getElementById('newQuestionDependentOn').value = '';
                document.getElementById('newQuestionDependentValue').value = '';
                document.getElementById('newQuestionOrder').value = '999';
                document.getElementById('newQuestionOptions').value = '';
                document.getElementById('optionsField').style.display = 'none';
                document.getElementById('editingPostGroupInfo').style.display = 'none';
                toggleCalculatedFieldOptions(); // Reset calculated fields UI
            }
        }

        function toggleOptionsField() {
            const inputType = document.getElementById('newQuestionInputType').value;
            document.getElementById('optionsField').style.display = inputType === 'select' ? 'block' : 'none';
        }

        function toggleCalculatedFieldOptions() {
            const isCalculated = document.getElementById('newQuestionCalculated').checked;
            // Hide dependency fields if calculated
            document.getElementById('newQuestionDependentOn').parentElement.style.display = isCalculated ? 'none' : 'block';
            document.getElementById('newQuestionDependentValue').parentElement.style.display = isCalculated ? 'none' : 'block';
            // Maybe hide Default Value too?
            document.getElementById('newQuestionDefault').parentElement.style.display = isCalculated ? 'none' : 'block';
        }

        function updateDynamicFields(triggerQuestionId, count) {
            const question = questions.find(q => q.id === triggerQuestionId);
            if (!question || !question.dynamic_fields) return;
            const config = question.dynamic_fields;

            if (config.type === 'gate') {
                dynamicFieldStructures[`${config.gate_type}Gates`] = generateGateFieldStructures(config, count);
            } else {
                dynamicFieldStructures.pulls = generatePullFieldStructures(config, count);
            }
            cleanupOrphanedAnswers(triggerQuestionId, count);
        }

        function generatePullFieldStructures(config, count) {
            const newFields = [];
            const template = config.template;
            for (let i = 1; i <= count; i++) {
                const nStr = i.toString();
                newFields.push({
                    id: template.id_template.replace('{n}', nStr),
                    question_text: template.text_template.replace('{n}', nStr),
                    input_type: template.input_type || 'number',
                    required: template.required || false,
                    placeholder: template.placeholder,
                    is_dynamic_part: true,
                    trigger_id: triggerIdFromConfig(config),
                    order: i,
                    style: template.style
                });
            }
            console.log(`Generated ${newFields.length} pull field structures.`);
            return newFields;
        }

        function generateGateFieldStructures(config, count) {
            const newGateGroups = [];
            const template = config.template;
            const triggerId = triggerIdFromConfig(config);
            for (let i = 1; i <= count; i++) {
                const nStr = i.toString();
                const currentGateFields = [];
                (template.fields || []).forEach((fieldTmpl, index) => {
                    currentGateFields.push({
                        id: fieldTmpl.id_template.replace('{n}', nStr),
                        question_text: fieldTmpl.text_template.replace('{n}', nStr),
                        input_type: fieldTmpl.input_type || 'number',
                        options: fieldTmpl.options, 
                        default: fieldTmpl.default,
                        required: fieldTmpl.required || false, 
                        is_post_field: false,
                        is_dynamic_part: true, 
                        trigger_id: triggerId, 
                        gate_number: i,
                        order: fieldTmpl.order ?? index, 
                        style: template.style
                    });
                });
                (template.post_fields || []).forEach((fieldTmpl, index) => {
                    currentGateFields.push({
                        id: fieldTmpl.id_template.replace('{n}', nStr),
                        question_text: fieldTmpl.text_template.replace('{n}', nStr),
                        input_type: fieldTmpl.input_type || 'number',
                        options: fieldTmpl.options, 
                        default: fieldTmpl.default,
                        required: fieldTmpl.required || false, 
                        is_post_field: true,
                        is_dynamic_part: true, 
                        trigger_id: triggerId, 
                        gate_number: i,
                        order: fieldTmpl.order ?? (100 + index), 
                        style: template.style
                    });
                });
                // Sort fields within the gate group
                currentGateFields.sort((a, b) => (a.order ?? 9999) - (b.order ?? 9999));
                newGateGroups.push(currentGateFields);
            }
            console.log(`Generated ${newGateGroups.length} ${config.gate_type} gate groups structures.`);
            return newGateGroups;
        }

        function cleanupOrphanedAnswers(triggerQuestionId, count) {
            // Determine prefix based on trigger ID (e.g., 'numberOfPulls' -> 'pull', 'numberOfSingleGates' -> 'singleGate')
            let prefix = triggerQuestionId.replace('numberOf', '');
            if (prefix.endsWith('s')) prefix = prefix.slice(0, -1); // Remove trailing 's'
            prefix = prefix.charAt(0).toLowerCase() + prefix.slice(1); // Make first letter lowercase

            // Regex needs to match the prefix, the number, and then the rest of the ID
            const regex = new RegExp(`^${prefix}(\\d+)([A-Z].*|Length)$`);

            Object.keys(answers).forEach(key => {
                const match = key.match(regex);
                if (match && match[1]) {
                    const fieldNumber = parseInt(match[1], 10);
                    if (fieldNumber > count) {
                        console.log(`Cleaning up orphaned answer: ${key}`);
                        delete answers[key];
                    }
                }
            });
        }

        function getAllQuestionsIncludingDynamic() {
            const dynamicFields = [
                ...dynamicFieldStructures.pulls, 
                ...dynamicFieldStructures.singleGates.flat(),
                ...dynamicFieldStructures.doubleGates.flat(), 
                ...dynamicFieldStructures.slidingGates.flat()
            ];
            const postGroupSubQuestions = questions
                .filter(q => q.is_post_group && q.post_group_questions)
                .flatMap(q => q.post_group_questions);
            
            // Filter out group titles themselves from this flat list
            return [...questions.filter(q => !q.is_post_group), ...postGroupSubQuestions, ...dynamicFields];
        }

        function triggerIdFromConfig(config) {
            return config.trigger_id || config.container_id_prefix.replace('dynamic-', '');
        }

        function renderForm() {
            console.log('Rendering form with admin mode:', isAdminMode);
            const formSections = document.getElementById('formSections');
            formSections.innerHTML = ''; // Clear existing content
            
            const { sections, sortedSectionNames } = getSections();
            
            sortedSectionNames.forEach(sectionName => {
                // Create section container
                const sectionContainer = document.createElement('div');
                sectionContainer.className = 'form-section';
                
                // Add section title
                const sectionTitle = document.createElement('h2');
                sectionTitle.className = 'section-title';
                sectionTitle.textContent = sectionName;
                sectionContainer.appendChild(sectionTitle);
                
                // Sort questions within this section
                const sectionQuestions = sections[sectionName].sort((a, b) => (a.order || 9999) - (b.order || 9999));
                
                // Render each question in this section
                sectionQuestions.forEach(question => {
                    // Skip questions with dependencies that aren't met
                    if (question.dependent_on && !isDependencyMet(question)) {
                        return;
                    }
                    
                    let questionElement;
                    if (question.is_post_group) {
                        questionElement = renderPostGroup(question);
                    } else {
                        questionElement = renderQuestion(question);
                    }
                    
                    sectionContainer.appendChild(questionElement);
                });
                
                // Add dynamic fields for this section if any
                if (sectionName === 'Basic Info') {
                    renderDynamicPulls(sectionContainer);
                } else if (sectionName === 'Gates') {
                    renderDynamicGates(sectionContainer, 'single');
                    renderDynamicGates(sectionContainer, 'double');
                    renderDynamicGates(sectionContainer, 'sliding');
                }
                
                // Only add the section if it has visible content
                if (sectionContainer.children.length > 1) { // > 1 because we always add the title
                    formSections.appendChild(sectionContainer);
                }
            });
            
            console.log('Form rendered successfully');
        }

        function getSections() {
            const sections = {};
            const sectionOrderMap = {}; // To store the first encountered order for a section
            const sectionNames = new Set(); // To get unique section names

            // Process main questions and group titles
            questions.forEach(question => {
                const section = question.section || 'Other';
                sectionNames.add(section);
                if (!sections[section]) {
                    sections[section] = [];
                    // Store the order of the first item found for this section for sorting sections later
                    sectionOrderMap[section] = question.order ?? 9999;
                }
                sections[section].push(question);
            });

            // Define explicit order, falling back to discovered order
            const explicitSectionOrder = ['Basic Info', 'Gates', 'Posts', 'Line Posts', 'Extra Options', 'Other'];
            const sortedSectionNames = Array.from(sectionNames).sort((a, b) => {
                const indexA = explicitSectionOrder.indexOf(a);
                const indexB = explicitSectionOrder.indexOf(b);

                if (indexA !== -1 && indexB !== -1) return indexA - indexB; // Both explicitly ordered
                if (indexA !== -1) return -1; // A is explicit, B is not
                if (indexB !== -1) return 1; // B is explicit, A is not

                // Neither is explicitly ordered, sort by the order of their first question
                return (sectionOrderMap[a] ?? 9999) - (sectionOrderMap[b] ?? 9999);
            });

            return { sections, sortedSectionNames };
        }

        function isDependencyMet(question) {
            if (!question.dependent_on) return true;
            
            const dependentValue = question.dependent_value;
            const actualValue = answers[question.dependent_on];
            
            if (Array.isArray(dependentValue)) {
                return dependentValue.includes(actualValue);
            }
            
            return actualValue === dependentValue;
        }

        function renderDynamicPulls(container) {
            if (dynamicFieldStructures.pulls.length === 0) return;
            
            const pullsContainer = document.createElement('div');
            pullsContainer.className = 'dynamic-fields-container';
            pullsContainer.id = 'dynamic-pulls-container';
            
            const pullsTitle = document.createElement('h3');
            pullsTitle.className = 'dynamic-fields-title';
            pullsTitle.textContent = 'Fence Pull/Section Lengths';
            pullsContainer.appendChild(pullsTitle);
            
            const pullsGrid = document.createElement('div');
            pullsGrid.className = 'dynamic-fields-grid';
            
            dynamicFieldStructures.pulls.forEach(pullQuestion => {
                const pullItem = renderQuestion(pullQuestion);
                pullItem.className += ' dynamic-field-item';
                pullsGrid.appendChild(pullItem);
            });
            
            pullsContainer.appendChild(pullsGrid);
            container.appendChild(pullsContainer);
        }

        function renderDynamicGates(container, gateType) {
            const gates = dynamicFieldStructures[`${gateType}Gates`];
            if (!gates || gates.length === 0) return;
            
            gates.forEach((gateFields, index) => {
                const gateNumber = index + 1;
                
                // Main gate container
                const gateContainer = document.createElement('div');
                gateContainer.className = 'gate-fields-container';
                gateContainer.id = `gate-fields-${gateType}-${gateNumber}`;
                
                // Gate title
                const gateTitle = document.createElement('h3');
                gateTitle.className = 'gate-fields-title';
                gateTitle.textContent = `${gateType.charAt(0).toUpperCase() + gateType.slice(1)} Gate ${gateNumber} Specifications`;
                gateContainer.appendChild(gateTitle);
                
                // Gate fields grid
                const gateGrid = document.createElement('div');
                gateGrid.className = 'gate-fields-grid';
                
                // Split fields into main gate fields and post fields
                const mainFields = gateFields.filter(f => !f.is_post_field);
                const postFields = gateFields.filter(f => f.is_post_field);
                
                // Render main gate fields
                mainFields.forEach(field => {
                    const fieldItem = renderQuestion(field);
                    fieldItem.className += ' gate-field-item';
                    gateGrid.appendChild(fieldItem);
                });
                
                gateContainer.appendChild(gateGrid);
                
                // Render post fields if any
                if (postFields.length > 0) {
                    const postContainer = document.createElement('div');
                    postContainer.className = 'gate-posts-container';
                    
                    const postTitle = document.createElement('h4');
                    postTitle.className = 'gate-posts-title';
                    postTitle.textContent = `Gate ${gateNumber} Post Details`;
                    postContainer.appendChild(postTitle);
                    
                    const postGrid = document.createElement('div');
                    postGrid.className = 'gate-fields-grid';
                    
                    postFields.forEach(field => {
                        const fieldItem = renderQuestion(field);
                        fieldItem.className += ' gate-field-item';
                        postGrid.appendChild(fieldItem);
                    });
                    
                    postContainer.appendChild(postGrid);
                    gateContainer.appendChild(postContainer);
                }
                
                container.appendChild(gateContainer);
            });
        }

        function renderQuestion(question) {
            const wrapper = document.createElement('div');
            wrapper.className = 'question-wrapper';
            wrapper.dataset.questionId = question.id; // Add data attribute for easier identification
            
            const label = createLabelElement(question);
            const input = createInputElement(question);
            wrapper.appendChild(label);
            wrapper.appendChild(input);

            if (isAdminMode) {
                // Find the correct source array and index for this question
                let sourceArray = questions;
                let currentIndex = questions.findIndex(q => q.id === question.id);
                
                // If not found in main array, it might be in a post group
                if (currentIndex === -1) {
                    for (const group of questions) {
                        if (group.is_post_group && group.post_group_questions) {
                            const subIndex = group.post_group_questions.findIndex(sq => sq.id === question.id);
                            if (subIndex !== -1) {
                                sourceArray = group.post_group_questions;
                                currentIndex = subIndex;
                                break;
                            }
                        }
                    }
                }
                
                const actionButtons = createAdminActionButtons(
                    question.id, 
                    currentIndex, 
                    sourceArray.length, 
                    sourceArray, 
                    handleDeleteQuestion, 
                    handleEditQuestion, 
                    handleMoveQuestion
                );
                wrapper.appendChild(actionButtons);
            }

            return wrapper;
        }

        function renderPostGroup(question) {
            const groupDiv = document.createElement('div');
            groupDiv.className = 'post-group-container';
            groupDiv.dataset.groupId = question.id; // Add data attribute for easier identification
            
            const groupTitle = document.createElement('h3');
            groupTitle.className = 'post-group-title';
            groupTitle.textContent = question.question_text;
            groupDiv.appendChild(groupTitle);

            if (isAdminMode) {
                const actionButtons = createAdminActionButtons(
                    question.id, 
                    questions.findIndex(q => q.id === question.id), 
                    questions.length, 
                    questions, 
                    handleDeleteQuestion, 
                    handleEditQuestion, 
                    handleMoveQuestion
                );
                groupTitle.appendChild(actionButtons);
            }

            (question.post_group_questions || []).forEach(subQ => {
                const subElem = renderQuestion(subQ);
                subElem.classList.add('post-field-item');
                groupDiv.appendChild(subElem);
            });
            
            return groupDiv;
        }

        function createAdminActionButtons(questionId, currentIndex, totalItems, sourceArray, deleteHandler, editHandler, moveHandler) {
            const container = document.createElement('div');
            container.className = 'action-buttons-container';
            
            const moveUpButton = document.createElement('button');
            moveUpButton.type = 'button'; 
            moveUpButton.className = 'action-button move'; 
            moveUpButton.textContent = '⬆️'; 
            moveUpButton.title = 'Move Up';
            moveUpButton.disabled = currentIndex <= 0; // Use <= 0 for safety
            moveUpButton.addEventListener('click', function(e) { 
                e.preventDefault();
                e.stopPropagation();
                console.log(`Moving ${questionId} up in array of length ${sourceArray.length}, from index ${currentIndex}`);
                moveHandler(questionId, 'up', sourceArray); 
            });
            
            const moveDownButton = document.createElement('button');
            moveDownButton.type = 'button'; 
            moveDownButton.className = 'action-button move'; 
            moveDownButton.textContent = '⬇️'; 
            moveDownButton.title = 'Move Down';
            moveDownButton.disabled = currentIndex >= totalItems - 1; // Use >= for safety
            moveDownButton.addEventListener('click', function(e) { 
                e.preventDefault();
                e.stopPropagation();
                console.log(`Moving ${questionId} down in array of length ${sourceArray.length}, from index ${currentIndex}`);
                moveHandler(questionId, 'down', sourceArray); 
            });
            
            const editButton = document.createElement('button');
            editButton.type = 'button'; 
            editButton.className = 'action-button edit'; 
            editButton.innerHTML = '✏️<span style="font-size:0.9em;margin-left:2px;">Edit</span>'; 
            editButton.title = 'Edit';
            editButton.addEventListener('click', function(e) { 
                e.preventDefault();
                e.stopPropagation();
                console.log(`Editing question ${questionId}`);
                editHandler(questionId); 
            });
            
            const deleteButton = document.createElement('button');
            deleteButton.type = 'button'; 
            deleteButton.className = 'action-button delete'; 
            deleteButton.innerHTML = '🗑️<span style="font-size:0.9em;margin-left:2px;">Del</span>'; 
            deleteButton.title = 'Delete';
            deleteButton.addEventListener('click', function(e) { 
                e.preventDefault();
                e.stopPropagation();
                console.log(`Deleting question ${questionId}`);
                deleteHandler(questionId); 
            });
            
            container.appendChild(moveUpButton); 
            container.appendChild(moveDownButton); 
            container.appendChild(editButton); 
            container.appendChild(deleteButton);
            
            return container;
        }

        function handleMoveQuestion(itemId, direction, sourceArray) {
            console.log(`handleMoveQuestion called for ${itemId}, direction: ${direction}, array length: ${sourceArray.length}`);
            
            // Find the item in the source array
            const currentIndex = sourceArray.findIndex(q => q.id === itemId);
            if (currentIndex === -1) {
                console.error(`Could not find item ${itemId} in source array`);
                return;
            }
            
            // Calculate target index
            const targetIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;
            if (targetIndex < 0 || targetIndex >= sourceArray.length) {
                console.error(`Target index ${targetIndex} is out of bounds (0-${sourceArray.length-1})`);
                return;
            }

            // Swap the items directly
            const temp = sourceArray[currentIndex];
            sourceArray[currentIndex] = sourceArray[targetIndex];
            sourceArray[targetIndex] = temp;
            
            // Also swap their order properties if they exist
            if (sourceArray[currentIndex].order !== undefined && sourceArray[targetIndex].order !== undefined) {
                const tempOrder = sourceArray[currentIndex].order;
                sourceArray[currentIndex].order = sourceArray[targetIndex].order;
                sourceArray[targetIndex].order = tempOrder;
            }
            
            console.log(`Moved item ${itemId} ${direction} from index ${currentIndex} to ${targetIndex}`);
            renderForm();
        }

        function handleEditQuestion(questionId) {
            console.log(`handleEditQuestion called for ${questionId}`);
            
            // First try to find the question in the main questions array
            let question = questions.find(q => q.id === questionId);
            let parentGroup = null;
            
            // If not found in main array, check post groups
            if (!question) {
                for (const group of questions) {
                    if (group.is_post_group && group.post_group_questions) {
                        const subQuestion = group.post_group_questions.find(sq => sq.id === questionId);
                        if (subQuestion) {
                            question = subQuestion;
                            parentGroup = group;
                            break;
                        }
                    }
                }
            }
            
            if (!question) {
                console.error(`Could not find question ${questionId} to edit.`);
                return;
            }

            console.log(`Found question to edit:`, question);
            
            // Set the editing state
            editingQuestionId = questionId;
            if (parentGroup) {
                console.log(`Question is part of post group: ${parentGroup.id}`);
                document.getElementById('editingPostGroupInfo').textContent = 
                    `Editing a question in post group: ${parentGroup.question_text}`;
                document.getElementById('editingPostGroupInfo').style.display = 'block';
            } else {
                document.getElementById('editingPostGroupInfo').style.display = 'none';
            }
            
            // Populate form with question data
            document.getElementById('newQuestionId').value = question.id;
            document.getElementById('newQuestionText').value = question.question_text;
            document.getElementById('newQuestionInputType').value = question.input_type || 'text';
            document.getElementById('newQuestionSection').value = question.section || 'Other';
            document.getElementById('newQuestionDefault').value = question.default || '';
            document.getElementById('newQuestionRequired').checked = !!question.required;
            document.getElementById('newQuestionCalculated').checked = !!question.calculated;
            document.getElementById('newQuestionDependentOn').value = question.dependent_on || '';
            document.getElementById('newQuestionDependentValue').value = 
                Array.isArray(question.dependent_value) 
                    ? question.dependent_value.join(', ') 
                    : (question.dependent_value || '');
            document.getElementById('newQuestionOrder').value = question.order || 999;
            
            // Handle options for select inputs
            if (question.options && Array.isArray(question.options)) {
                document.getElementById('newQuestionOptions').value = question.options.join(', ');
                document.getElementById('optionsField').style.display = 'block';
            } else {
                document.getElementById('newQuestionOptions').value = '';
                document.getElementById('optionsField').style.display = 
                    question.input_type === 'select' ? 'block' : 'none';
            }

            // Update UI
            document.getElementById('addQuestionButton').textContent = 'Save Changes';
            toggleAddQuestionFormUI(true);
        }

        function handleAddQuestion() {
            const id = document.getElementById('newQuestionId').value.trim();
            const questionText = document.getElementById('newQuestionText').value.trim();
            const inputType = document.getElementById('newQuestionInputType').value;
            const section = document.getElementById('newQuestionSection').value;
            const defaultValue = document.getElementById('newQuestionDefault').value.trim();
            const required = document.getElementById('newQuestionRequired').checked;
            const calculated = document.getElementById('newQuestionCalculated').checked;
            const order = parseInt(document.getElementById('newQuestionOrder').value, 10) || 999;
            const optionsString = document.getElementById('newQuestionOptions').value.trim();
            const dependentOn = document.getElementById('newQuestionDependentOn').value.trim();
            const dependentValue = document.getElementById('newQuestionDependentValue').value.trim();

            if (!id || !questionText) {
                alert('Question ID and Question Text are required.');
                return;
            }
            
            // Create the question object
            const questionData = { 
                id, 
                question_text: questionText, 
                input_type: inputType, 
                section, 
                required, 
                order 
            };

            if (calculated) questionData.calculated = true;
            if (defaultValue) questionData.default = defaultValue;
            if (dependentOn && dependentValue) {
                questionData.dependent_on = dependentOn;
                questionData.dependent_value = dependentValue;
            }

            if (inputType === 'select') {
                const options = optionsString.split(',').map(opt => opt.trim()).filter(opt => opt !== '');
                if (options.length === 0) {
                    alert('Please provide at least one option for the select field (comma-separated).');
                    return;
                }
                questionData.options = options;
            }

            console.log(`handleAddQuestion: ${editingQuestionId ? 'Editing existing' : 'Adding new'} question`);
            
            // Check if we're editing an existing question or adding a new one
            if (editingQuestionId) {
                let updated = false;
                
                // First try main questions array
                const mainIndex = questions.findIndex(q => q.id === editingQuestionId);
                if (mainIndex !== -1) {
                    // If ID changed, check for duplicates
                    if (id !== editingQuestionId && getAllQuestionsIncludingDynamic().some(q => q.id === id)) {
                        alert(`A question with ID "${id}" already exists. Please use a unique ID.`);
                        return;
                    }
                    
                    // Preserve special properties
                    const originalQuestion = questions[mainIndex];
                    if (originalQuestion.dynamic_fields) {
                        questionData.dynamic_fields = originalQuestion.dynamic_fields;
                    }
                    if (originalQuestion.is_post_group) {
                        questionData.is_post_group = true;
                        questionData.post_group_questions = originalQuestion.post_group_questions;
                    }
                    
                    // Update the question
                    questions[mainIndex] = questionData;
                    updated = true;
                    console.log(`Updated main question at index ${mainIndex}:`, questionData);
                } else {
                    // Check post groups
                    for (const group of questions) {
                        if (!group.is_post_group || !group.post_group_questions) continue;
                        
                        const subIndex = group.post_group_questions.findIndex(sq => sq.id === editingQuestionId);
                        if (subIndex !== -1) {
                            // If ID changed, check for duplicates
                            if (id !== editingQuestionId && getAllQuestionsIncludingDynamic().some(q => q.id === id)) {
                                alert(`A question with ID "${id}" already exists. Please use a unique ID.`);
                                return;
                            }
                            
                            // Update the sub-question
                            group.post_group_questions[subIndex] = questionData;
                            updated = true;
                            console.log(`Updated sub-question in group ${group.id} at index ${subIndex}:`, questionData);
                            break;
                        }
                    }
                }
                
                if (!updated) {
                    console.error(`Could not find question ${editingQuestionId} to update.`);
                    alert(`Error: Could not find the question to update.`);
                }
                
                // Reset editing state
                editingQuestionId = null;
                document.getElementById('addQuestionButton').textContent = 'Add Question';
                document.getElementById('editingPostGroupInfo').style.display = 'none';
            } else {
                // Adding new question - check for duplicate IDs
                if (getAllQuestionsIncludingDynamic().some(q => q.id === id)) {
                    alert(`A question with ID "${id}" already exists. Please use a unique ID.`);
                    return;
                }
                
                // Add to questions array
                questions.push(questionData);
                console.log('Added new question:', questionData);
            }
            
            // Reset form and re-render
            toggleAddQuestionFormUI(false);
            renderForm();
        }

        function downloadFormHtmlCss() {
            console.log('Preparing form HTML/CSS for download...');

            if (!isAdminMode) {
                alert('Please enter Admin Mode first to access download.');
                return;
            }

            // 1. Temporarily hide admin controls for clean HTML capture
            const originalAdminMode = isAdminMode;
            isAdminMode = false; // Set mode to non-admin
            renderForm(); // Re-render WITHOUT admin buttons/edit inputs
            updateCalculatedFieldDisplay(); // Ensure calculated fields are up-to-date in the non-admin view

            // 2. Capture the clean form HTML
            const formContainer = document.getElementById('fenceCalculator');
            // Exclude the admin toggle button and the admin panel itself from the download
            const adminToggleButton = document.getElementById('toggleEditorMode');
            const adminPanelElement = document.getElementById('adminPanel');
            const originalToggleDisplay = adminToggleButton.style.display;
            const originalPanelDisplay = adminPanelElement.style.display;
            adminToggleButton.style.display = 'none'; // Hide button
            adminPanelElement.style.display = 'none'; // Hide panel
            const cleanFormHtml = formContainer.innerHTML; // Get HTML of container content
            adminToggleButton.style.display = originalToggleDisplay; // Restore button display
            adminPanelElement.style.display = originalPanelDisplay; // Restore panel display

            // 3. Restore admin mode and re-render
            isAdminMode = originalAdminMode; // Set mode back
            renderForm(); // Re-render WITH admin controls
            updateCalculatedFieldDisplay(); // Update calculated fields in admin view

            // 4. Get CSS content
            let cssContent = '';
            const styleElement = document.querySelector('style');
            if (styleElement) {
                cssContent = styleElement.textContent || styleElement.innerText;
            } else {
                console.warn('Could not find <style> tag to extract CSS.');
            }

            // 5. Create complete HTML content for download
            const fullHtmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generated Fence Calculator Form</title>
    <style>
${cssContent}
    </style>
</head>
<body>
    <div class="form-container" id="fenceCalculator">
        ${cleanFormHtml}
        <script>
            // Optional: Add basic JS needed for the standalone form?
            // For now, it's just the static HTML structure + CSS.
            // Calculation logic, dynamic fields etc. would NOT work
            // without including and adapting the main script.
            console.log("Static form loaded.");
        <\/script>
    </div>
</body>
</html>`;

            // 6. Create blob and trigger download
            const blob = new Blob([fullHtmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'fence_calculator_form.html'; // Filename
            document.body.appendChild(a); // Required for Firefox
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url); // Clean up

            console.log('Download initiated.');
        }
    </script>
</body>
</html>